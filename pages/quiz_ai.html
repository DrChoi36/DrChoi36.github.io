<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NotebookLM Style Flashcards v4</title>
    <style>
        /* 1. 기본 스타일 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            flex-direction: column;
        }

        /* 2. 메인 컨테이너 */
        #quiz-container {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 20px;
            position: relative; /* 카운터 위치 잡기 위해 */
        }

        /* 3. 카드 영역 */
        .card-wrapper {
            perspective: 1000px;
            width: 500px;
            height: 300px;
            cursor: pointer;
            position: relative;
        }

        /* 카드 번호 표시 (새로 추가됨) */
        #card-counter {
            position: absolute;
            top: -40px; /* 카드 바로 위 */
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            font-weight: bold;
            color: #555;
            background-color: #e9ecef;
            padding: 5px 15px;
            border-radius: 15px;
        }

        /* 4. 실제 카드 */
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .card-inner.flipped {
            transform: rotateY(180deg);
        }

        /* 5. 앞/뒷면 공통 */
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 30px;
            box-sizing: border-box;
            border-radius: 15px;
            background-color: white;
            border: 1px solid #ddd;
        }

        .card-front {
            z-index: 2;
            transform: rotateY(0deg);
        }
        
        .card-back {
            transform: rotateY(180deg);
            background-color: #fafafa;
        }

        /* 텍스트 스타일 */
        .question-text {
            font-size: 1.4rem;
            font-weight: bold;
            color: #333;
            line-height: 1.5;
            word-break: keep-all; /* 단어 단위 줄바꿈 */
        }

        .answer-text {
            font-size: 1.2rem;
            color: #555;
            line-height: 1.6;
            word-break: keep-all;
        }

        .label {
            font-size: 0.8rem;
            color: #999;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 600;
        }

        /* 6. 네비게이션 버튼 */
        .nav-btn {
            padding: 0;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.3s, transform 0.1s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        .nav-btn:hover {
            background-color: #0056b3;
        }

        .nav-btn:active {
            transform: scale(0.95);
        }

        /* 7. 안내 및 완료 화면 */
        .instructions {
            margin-top: 50px;
            font-size: 0.9rem;
            color: #888;
            background: #e9ecef;
            padding: 8px 20px;
            border-radius: 20px;
        }

        #completion-message {
            display: none;
            text-align: center;
            animation: fadeIn 0.5s;
        }

        #completion-message h1 {
            color: #28a745;
            margin-bottom: 20px;
        }

        #restart-btn {
            padding: 10px 20px;
            font-size: 1rem;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

    <div id="quiz-container">
        
        <!-- 왼쪽 버튼 -->
        <button class="nav-btn" onclick="prevCard()">❮</button>

        <!-- 중앙 카드 -->
        <div class="card-wrapper" onclick="flipCard()">
            <!-- 카드 카운터 (예: 1 / 30) -->
            <div id="card-counter">1 / 30</div>

            <div class="card-inner" id="card-inner">
                <!-- 앞면 -->
                <div class="card-face card-front">
                    <div class="label">Question</div>
                    <div class="question-text" id="question-text">Loading...</div>
                </div>
                <!-- 뒷면 -->
                <div class="card-face card-back">
                    <div class="label">Answer & Explanation</div>
                    <div class="answer-text" id="answer-text">Loading...</div>
                </div>
            </div>
        </div>

        <!-- 오른쪽 버튼 -->
        <button class="nav-btn" onclick="nextCard()">❯</button>
    </div>

    <div class="instructions" id="instructions">
        [Space]: 뒤집기 / [⬅️]: 이전 / [➡️]: 다음
    </div>

    <div id="completion-message">
        <h1>Thank You!</h1>
        <p>모든 학습을 완료했습니다.</p>
        <br>
        <button id="restart-btn" onclick="restartQuiz()">처음으로 돌아가기</button>
    </div>

    <script>
        // ==========================================
        // 30개 문제 데이터 (JSON)
        // ==========================================
        const quizData = [
            {
        "question": "합성곱(convolution) 연산은 각 배열의 원소끼리 어떻게 계산하나요?",
        "answer": "각 배열의 원소끼리 곱한 후 더합니다."
    },
    {
        "question": "합성곱 연산에서 미끄러지는 배열의 간격을 조절하는 것을 무엇이라 하나요?",
        "answer": "스트라이드(stride)입니다."
    },
    {
        "question": "원본 배열의 양 끝에 빈 원소를 추가하는 것을 무엇이라 하나요?",
        "answer": "패딩(padding)입니다."
    },
    {
        "question": "원본 배열에 패딩을 추가하지 않고 커널이 배열의 끝으로 갈 때까지 계산하는 방식은?",
        "answer": "밸리드 패딩(valid padding)입니다."
    },
    {
        "question": "밸리드 패딩을 적용하면 출력 배열의 크기는 원본보다 어떻게 되나요?",
        "answer": "항상 작아집니다."
    },
    {
        "question": "원본 배열의 모든 요소가 동일하게 연산에 참여하도록 하는 패딩 방식은?",
        "answer": "풀 패딩(full padding)입니다."
    },
    {
        "question": "패딩을 할 때 가상의 원소로 0을 사용하는 것을 무엇이라 하나요?",
        "answer": "제로 패딩(zero padding)입니다."
    },
    {
        "question": "출력 배열의 길이를 원본 배열의 길이와 동일하게 만드는 패딩 방식은?",
        "answer": "세임 패딩(same padding)입니다."
    },
    {
        "question": "합성곱 신경망에서 주로 사용하는 패딩 방식은 무엇인가요?",
        "answer": "세임 패딩(same padding)입니다."
    },
    {
        "question": "합성곱층과 풀링층을 거쳐 만들어진 결과를 무엇이라 부르나요?",
        "answer": "특성 맵(feature map)입니다."
    },
    {
        "question": "합성곱이 일어나는 층을 무엇이라 하나요?",
        "answer": "합성곱층(convolution layer)입니다."
    },
    {
        "question": "풀링(pooling) 연산이 일어나는 층을 무엇이라 하나요?",
        "answer": "풀링층(pooling layer)입니다."
    },
    {
        "question": "특성 맵 위를 스캔하며 최댓값을 고르는 풀링 방식은?",
        "answer": "최대 풀링(max pooling)입니다."
    },
    {
        "question": "풀링 영역의 평균값을 계산하는 방식은?",
        "answer": "평균 풀링(average pooling)입니다."
    },
    {
        "question": "이미지 분류 작업에서 주로 선호되는 풀링 방식과 그 이유는?",
        "answer": "최대 풀링입니다. 가장 큰 특징을 유지하는 성질이 있기 때문입니다."
    },
    {
        "question": "평균 풀링을 잘 사용하지 않는 이유는 무엇인가요?",
        "answer": "특징들을 희석시킬 가능성이 높기 때문입니다."
    },
    {
        "question": "이미지의 픽셀이 가진 색상을 표현하기 위해 필요한 정보를 무엇이라 하나요?",
        "answer": "채널(channel)입니다."
    },
    {
        "question": "컬러 이미지는 보통 몇 개의 채널로 구성되나요?",
        "answer": "3개(Red, Green, Blue)입니다."
    },
    {
        "question": "합성곱 신경망(CNN)의 기본적인 구조 순서는?",
        "answer": "합성곱층 -> 풀링층 -> 완전 연결층 -> 출력층"
    },
    {
        "question": "합성곱층에 주로 적용되는 활성화 함수는 무엇인가요?",
        "answer": "렐루(ReLU) 함수입니다."
    },
    {
        "question": "렐루(ReLU) 함수에서 x가 0보다 클 때의 출력값은?",
        "answer": "x (입력값 그대로)입니다."
    },
    {
        "question": "렐루(ReLU) 함수에서 x가 0 이하일 때의 출력값은?",
        "answer": "0입니다."
    },
    {
        "question": "뉴런이 계속 0을 출력하여 학습이 진행되지 않는 상태를 무엇이라 하나요?",
        "answer": "Dying ReLU입니다."
    },
    {
        "question": "Dying ReLU 문제를 해결하기 위해 x가 0 이하일 때 작은 값을 출력하게 만든 함수는?",
        "answer": "리키 렐루(Leaky ReLU)입니다."
    },
    {
        "question": "입력층으로 갈수록 기울기가 점차 작아져 학습이 안 되는 현상은?",
        "answer": "기울기 소실(Gradient Vanishing)입니다."
    },
    {
        "question": "시그모이드 함수가 기울기 소실을 유발하는 이유는?",
        "answer": "입력의 절대값이 클수록 출력값이 0 또는 1에 수렴하여 기울기가 0에 가까워지기 때문입니다."
    },
    {
        "question": "합성곱 신경망의 입력 데이터는 일반적으로 몇 차원 배열인가요?",
        "answer": "4차원 배열 (배치, 높이, 너비, 채널)입니다."
    },
    {
        "question": "케라스의 Conv2D 함수에서 첫 번째 매개변수는 무엇을 의미하나요?",
        "answer": "필터(커널)의 개수입니다."
    },
    {
        "question": "Conv2D(10, (3, 3), ...) 코드에서 (3, 3)은 무엇을 의미하나요?",
        "answer": "커널(필터)의 크기(높이, 너비)입니다."
    },
    {
        "question": "MaxPooling2D((2, 2))는 입력 이미지를 어떻게 변화시키나요?",
        "answer": "가로와 세로 크기를 각각 절반으로 줄입니다."
    },
    {
        "question": "2차원 특성 맵을 1차원으로 펼치는 역할을 하는 층은?",
        "answer": "Flatten 층입니다."
    },
    {
        "question": "다중 분류 문제에서 출력층에 주로 사용하는 활성화 함수는?",
        "answer": "소프트맥스(Softmax) 함수입니다."
    },
    {
        "question": "손실 함수의 최적값에 가까워질수록 학습률을 낮춰주는 옵티마이저는?",
        "answer": "아담(Adam, Adaptive Moment Estimation)입니다."
    },
    {
        "question": "SGD 옵티마이저의 우리말 이름은?",
        "answer": "확률적 경사 하강법입니다."
    },
    {
        "question": "이전에 내려오던 관성 방향을 기억하여 추가로 이동하는 옵티마이저 기법은?",
        "answer": "모멘텀(Momentum)입니다."
    },
    {
        "question": "RMSProp과 Momentum을 결합한 옵티마이저는?",
        "answer": "Adam입니다."
    },
    {
        "question": "검증 손실(val_loss)이 감소하다가 다시 증가하기 시작하면 무엇을 의심해야 하나요?",
        "answer": "과대적합(Overfitting)입니다."
    },
    {
        "question": "신경망에서 과대적합을 줄이기 위해 일부 뉴런을 무작위로 비활성화하는 기법은?",
        "answer": "드롭아웃(Dropout)입니다."
    },
    {
        "question": "드롭아웃은 어떤 효과를 주나요?",
        "answer": "특정 뉴런에 과도하게 의존하는 것을 막아 과대적합을 방지합니다."
    },
    {
        "question": "패션 MNIST 데이터셋의 이미지 크기는 얼마인가요?",
        "answer": "28 x 28 픽셀입니다."
    },
    {
        "question": "이미지 데이터의 픽셀 값을 0~255에서 0~1 사이로 바꾸는 과정을 무엇이라 하나요?",
        "answer": "스케일링(Scaling) 또는 정규화(Normalization)입니다."
    },
    {
        "question": "케라스에서 카테고리형 데이터를 원-핫 인코딩으로 변환하는 함수는?",
        "answer": "to_categorical()입니다."
    },
    {
        "question": "model.summary()에서 모델의 전체 파라미터 개수를 확인할 수 있는 항목은?",
        "answer": "Total params입니다."
    },
    {
        "question": "학습 시 검증 데이터를 사용하여 성능을 평가하기 위해 fit() 함수에 사용하는 인자는?",
        "answer": "validation_data입니다."
    },
    {
        "question": "합성곱 신경망에서 가중치(W)는 몇 차원 배열로 표현되나요?",
        "answer": "4차원 (높이, 너비, 채널, 개수)입니다."
    },
    {
        "question": "전체 데이터셋을 한 번 훈련하는 주기를 무엇이라 하나요?",
        "answer": "에포크(Epoch)입니다."
    },
    {
        "question": "한 번의 가중치 업데이트에 사용되는 데이터 샘플의 묶음 크기는?",
        "answer": "배치 사이즈(Batch size)입니다."
    },
    {
        "question": "하이퍼볼릭 탄젠트(tanh) 함수의 출력 범위는?",
        "answer": "-1에서 1 사이입니다."
    },
    {
        "question": "배치 차원을 포함한 흑백 이미지의 입력 쉐이프(shape)는?",
        "answer": "(배치 크기, 높이, 너비, 1)입니다."
    },
    {
        "question": "Conv2D 층을 통과한 출력 데이터의 차원 수는?",
        "answer": "4차원 (배치, 높이, 너비, 필터 수)입니다."
    }
        ];

        // ==========================================
        // 로직
        // ==========================================
        let currentCardIndex = 0;
        const cardInner = document.getElementById('card-inner');
        const questionText = document.getElementById('question-text');
        const answerText = document.getElementById('answer-text');
        const cardCounter = document.getElementById('card-counter'); // 카운터 엘리먼트
        
        const quizContainer = document.getElementById('quiz-container');
        const instructions = document.getElementById('instructions');
        const completionMessage = document.getElementById('completion-message');

        function loadCard(index) {
            // 카드 리셋 (항상 앞면으로)
            cardInner.classList.remove('flipped');

            // 텍스트 업데이트 (애니메이션 딜레이)
            setTimeout(() => {
                questionText.innerHTML = quizData[index].question;
                answerText.innerHTML = quizData[index].answer;
                
                // [NEW] 카운터 업데이트
                cardCounter.textContent = `${index + 1} / ${quizData.length}`;
            }, 150);
        }

        function flipCard() {
            cardInner.classList.toggle('flipped');
        }

        function nextCard() {
            if (currentCardIndex < quizData.length - 1) {
                currentCardIndex++;
                loadCard(currentCardIndex);
            } else {
                finishQuiz();
            }
        }

        function prevCard() {
            if (currentCardIndex > 0) {
                currentCardIndex--;
                loadCard(currentCardIndex);
            }
        }

        function finishQuiz() {
            quizContainer.style.display = 'none';
            instructions.style.display = 'none';
            completionMessage.style.display = 'block';
        }

        function restartQuiz() {
            currentCardIndex = 0;
            quizContainer.style.display = 'flex'; 
            instructions.style.display = 'block';
            completionMessage.style.display = 'none';
            loadCard(0);
        }

        document.addEventListener('keydown', function(event) {
            if (quizContainer.style.display === 'none') return;

            if (event.code === 'Space') {
                event.preventDefault();
                flipCard();
            } else if (event.code === 'ArrowRight' || event.code === 'Enter') {
                event.preventDefault();
                nextCard();
            } else if (event.code === 'ArrowLeft') {
                event.preventDefault();
                prevCard();
            }
        });

        // 초기 실행
        loadCard(currentCardIndex);

    </script>
</body>
</html>